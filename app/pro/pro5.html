##一.前言
>都知道JS存在三种作用域，即全局，函数，块级。其实是没有块级作用域的，但我们可以通过闭包来实现它。
##二.函数作用域
>很好理解，在函数内部声明的变量在函数调用后会销毁
##三.块级作用域
在if，while，for等代码体用{}包括的，成为块级作用域，但是在JS中没这说法。
比如

      <script>
          for(var i=0;i<10;i++)
          {
              console.log(i);
          }
          alert(i)   //    9
      </script>
问题出来了，按理说正常情况是控制台输出0~9，弹出undefined，但是alert出来的却是9，
>那这足以说明咱们的JS是不存在块级作用域的，块里面的变量是被挂载在window上的。

那么这会引发一个问题，看下面代码：

      var arrs=[];
      <script>
          for(var i=0;i<10;i++)
          {
              arrs[i]=function(){
                   console.log(i);
              }
          }
          arrs[0]   //   9
          arrs[1]   //   9
          ..........
      </script>

这里你不管执行 第几个函数都是打印9，原因有两个，第一因为JS中不存在块级作用域，i的声明是挂载在window上的，再一个，函数在执行的时候获取到的i为循环最后一次+1的i，所以恒定为9。
解决办法：利用闭包虚构一个块级作用域，并将i的值传入。
 
     var arrs=[];
      <script>
          for(var i=0;i<10;i++)
          {
             (function(i){
                 arrs[i]=function(){
                      console.log(i);
                 }
             })(i)  //将循环的i的值传入
          }
          arrs[0]   //   0
          arrs[1]   //   1
          ..........
      </script>

此时当函数执行的时候会拿到这个立即执行函数的i的值，而立即执行函数的值是for循环传入的，所以就能正常输出0~9。